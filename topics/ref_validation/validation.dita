<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/topic.dtd">
<topic id="topic-validation">
    <title>Using Validation</title>
    <body>
        <p>Validation is Agavi's way to make sure that the request data conforms to certain rules.
            If these rules are violated, the framework would refuse to execute your code. When used
            correctly, validation nullifies the threats of malformed data. Malformed data is
            anything from the user typing an errorneous URL that contains unexpected parameters over
            validating form input data to preventing malicious user from attacking your application
            by using specially crafted input parameters. Attacks include the full range from <term
                >XSS-attacks</term> to <term>SQL-Injection</term>. Validation is a core feature to
            make your application as robust and error-tolerant as possible. Incorrect input data may
            include any user supplied data, ranging from GET and POST parameters, Cookies and
            HTTP-Headers in the web-context over to environment variables and commandline arguments
            in console contexts.</p>
    </body>
    <topic id="validation-validation-methods">
        <title>Validation Methods</title>
        <body>
            <p>There are two methods of validation, one using the <indexterm
                >ValidationManager</indexterm> and various <indexterm>Validators</indexterm> and for
                more fine grained control the validate*() methods. Both methods can be combined, it
                is a common use-case to first validate parameters for formal correctness with a
                validator and then perform additional checks with a validate method.</p>
        </body>
    </topic>
    <topic id="validation-validation-modes">
        <title>Validation Modes</title>
        <body>
            <p>Agavi supports three validation modes: <dl>
                    <dlentry>
                        <dt>STRICT</dt>
                        <dd>Strict validation requires every piece of input data to be validated.
                            Input data that is not validated will not be available to the business
                            logic in actions. This is the recommended mode as it is the most secure
                            and robust. </dd>
                    </dlentry>
                    <dlentry>
                        <dt>RELAXED</dt>
                        <dd>Relaxed validation uses any defined validators but passes any
                            unvalidated parameter as well.</dd>
                    </dlentry>
                    <dlentry>
                        <dt>CONDITIONAL</dt>
                        <dd>Conditional validation acts like relaxed validation as long as no
                            validator is registered. When a single validator is defined, it acts
                            like strict validation.</dd>
                    </dlentry>
                </dl>The validation mode can be by calling AgaviValidationManager::setMode() or in
                the factories.xml via the parameter 'mode'. The default for production envirnoments
                is 'strict', for dev environments 'conditional'.</p>
            <codeblock>		&lt;validation_manager class="AgaviValidationManager">
			&lt;ae:parameter name="mode">strict&lt;/ae:parameter>
		&lt;/validation_manager></codeblock>
        </body>
    </topic>
    <topic id="validation-other-features">
        <title>Other Validation Features</title>
        <body>
            <p>Validation can perform other duties than just checking whether input data conforms to
                a given set of rules. Validation can take care of normalizing the input data if
                multiple formats are allowed. Date formats usually are locale specific and even
                within a given locale, multiple formats are common. The AgaviDateValidator can take
                care of normalizing all these formats and all the application ever gets to see is a
                DateTime object or any other defined format. The same idea can be applied to number
                formats and even to custom validators that can transform an ID into an object
                retrieved from the database.</p>
        </body>
    </topic>
</topic>
