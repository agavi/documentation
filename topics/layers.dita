<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN"
	  "http://docs.oasis-open.org/dita/dtd/topic.dtd">
<topic id="layers">
  <title>How layered output works</title>
  <body>
    <p>Agavi gives the application developer an advanced facility that
    can compose output in many combinations. Views can use this
    facility to produce output as generic or as specific as needed.</p>
    <p>In order to dress Bloggie, we need to reconfigure the output
    rendering to use our new templates. To do that, you need to
    understand the basic theory of how layered output works, and learn
      how to bend it to suit your needs.
    </p>
    <section>
      <title>Layered output in Agavi</title>
      <p>
	An Agavi developer has the choice of either composing the
      output directly in a View or use the built-in rendering
      mechanism. If a View's <apiname>executeXXX</apiname> method does
      not return anything, Agavi engages its own rendering.
      </p>
      <p>
	To make Agavi render the output, a View configures a number of
	objects called <keyword>Layers</keyword>
	and <keyword>Renderers</keyword>. This configuration is called
	a <keyword>layout</keyword>. Layouts can be composed in PHP
	code during run time or loaded from a preset configuration.
      </p>
      <p>A <keyword>Layer</keyword> is an object that knows where the template
      is. Depending on what your code does, a View can have one or
      more Layers.</p>
      <p>
	A <keyword>Renderer</keyword> is an Agavi adapter class that
      knows how to process a certain template type into output. Agavi
      ships with several such adapters, such as plain PHP template
      renderer, Smarty renderer, DWOO renderer and so on.
      </p>
      <p>Combining Layers and Renderers enables great flexibility: for
	example, some of the templates your application uses may be
	stored in the database, and others on disk. You can also use
	Slots to place output of other actions on a template.</p>
      </section>
    <section>
      <title>Mechanics of the rendering process</title>
      <p>
	When executed, a View configures the layout - a simple array
      of Layer objects. The rendering process walks the layout,
      applying a corresponding Renderer adapter to every configured
      Layer's template. The resulting output is collected and made
      available to the next step. This template processing scheme is a
      bit unusual, but has many practical advantages.
      </p>
      <p>
	In order to understand how this mechanism is used in practice,
	imagine that Layers are kept in a vertical stack - that is,
	they sit on top of each other. The rendering is performed from
	top to bottom, and every rendered layer can access the
	finished output of the Layer above it. The output of the last
	(bottom) Layer becomes the output (the response body) of the
	View.
      </p>
      <p>Let's imagine that we're making a simple page with a header
	and a footer. The complete HTML output may look something like this:</p>
      <codeblock conref="examples.xml#layouts-full-html-example" class="xml"/>
      <p>
	In a traditionally organized
	templating system, the View's template would include a header
	and a footer, like in the example below.
      </p>
      <p>Header:</p>
      <codeblock conref="examples.xml#layouts-classic-html-header" class="xml"/>
      <p>Footer:</p>
      <codeblock conref="examples.xml#layouts-classic-html-footer" class="xml"/>
      <p>Page contents:</p>
      <codeblock conref="examples.xml#layouts-classic-html-page" class="xml"/>
      <p>In Agavi you do the exact opposite: create a template with
	header, footer and a special space to include the contents of
	another "inner" template. In Agavi slang, such a template is
	called a <keyword>decorator</keyword>, because it wraps around
	content generated by other templates, thus decorating it. Your
	View's specific template is rendered in the top layer, and its
	contents are passed to the bottom, or decorator Layer. The
	decorator wraps around the content of the "inner" layer,
	resulting in a full HTML page. 
      </p>
      <p>Decorator template:</p>
      <codeblock conref="examples.xml#layouts-agavi-html-decorator" class="xml"/>
      <p>View's content template:</p>
      <codeblock conref="examples.xml#layouts-agavi-html-view-template" class="xml"/>
      <p>As you can see in the decorator, a special variable called
	<varname>$inner</varname> contains the value of the "inner"
	layer - in this case, the second template. The rendered output
	will look exactly the same as in the previous case.</p>
      <p>Note that Agavi templates do not call each other by name,
	because the rendering system knows how to compose
	them. Configuring the rendering system to do so is
	demonstrated in the next chapter.
      </p>
    </section>
  </body>
</topic>
