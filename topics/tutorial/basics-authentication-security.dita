<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN"
	  "http://docs.oasis-open.org/dita/dtd/topic.dtd">
<topic id="basic-auth-security">
  <title>Basics of authentication and security</title>

  <body>
    <section>
      <title>How web application sessions work</title>
      <p>HTTP is a stateless protocol that does not provide a way to
	maintain a relationship between requests, thus making it hard
	to produce personalized pages and restricted access
	areas. Without special means, a web application is unable to
	distinguish requests made by user A and user B. This problem
	is solved by using cookies and cookie-based <keyword>session
	  management</keyword>. A web application session is a data
	container that stores user-specific data such as the identity
	of the current user. A session is associated with a cookie or
	another session token. When a request arrives, the session is
	resurrected from storage according to the session key stored
	in the cookie. The application is thus able to behave towards
	its user in a personalized way.
      </p>
      <p>Use of a session container creates an illusion that some
	data persists across requests. Agavi provides skeleton
	session-based services to authenticate users and ensure that
	security policies are enforced. 
      </p>
      <p>The session container is implemented in a
	singleton <apiname>User</apiname> object. We will use its
	facilities to create the administrative part of our blog which
	require authentication and authorization.
      </p>
      <note type="tip">You should distinguish between authentication
	and authorization. <keyword>Authentication</keyword> is a
	procedure of establishing the identity of an user,
	wherease <keyword>authorization</keyword> is the procedure of
	verifying a given authenticated user's permission to perform a
	certain action.</note>
    </section>

    <section>
      <title>User authentication</title>
      <p>A stock Agavi configuration uses a simple authorization check
	before Actions are executed. Actions specify their security
	requirements and Agavi enforces them. The security mechanism
	is extensible and several security architectures on top of it
	are available.</p>
      <p>Agavi Actions can be <keyword>secure</keyword>
	and <keyword>non-secure</keyword>. An Action specifies whether
	it's secure or not by the return value of
	its <apiname>isSecure</apiname>() method:</p>
      <codeblock class="php">
class Module_SomeAction extends SomeBaseAction
{
   /* .... */

   public function isSecure()
   {
     return true; // Only authenticated users can
                  // execute this Action
   }
}
      </codeblock>
      <p>A <keyword>non-secure</keyword> Action is public and is not subjected to any
	security checks.</p>

      <p>A <keyword>secure</keyword> Action can only be executed if the user is
	authenticated. If an unauthenticated web client attempts to
	access a secure Action, Agavi will divert execution, instead
	calling a special system Action (called the "Login Action") to
	give the user an opportunity to authenticate.</p>

      <note type="tip">In the Admin module that we're about to create, all Actions
	will be labelled as secure, except the Login action which must
	be accessible by everyone.</note>
    </section>
    <section>
      <title>Access authorization</title>
      <p>On top of the authentication check, Agavi provides a
	credential-based mechanism to allow better control over who
	can do what.</p>
      <p>Your application assigns named access credentials to the User
	object (typically during the login procedure). Actions that need
	access restrictions specify which credentials must be present in
	the User object to allow execution of the Action.</p>
      <p>An Action declares which credentials are required from the
	User object through its <apiname>getCredentials</apiname>()
	method. If this method doesn't return anything, credentials
	aren't required and anyone authenticated may call the
	Action.</p>
      <p>If the authorization check discovers that the user doesn't
	have all the credentials required to execute the Action,
	execution is diverted to a system action called the "Secure
	Action" which handles the attempts to access restricted
	Actions without authorization.</p>
    </section>

    <section>
      <title>Using the User object</title>
      <p>Agavi User object is the persistent session container -
	anything you store in it will be automatically restored on the
	next request in the same session.  The object is accessed
	through the getUser() method of the global Context object.</p>
      <p>To read and store values in the User object, use the standard Agavi attribute container methods
	<apiname>getAttribute()</apiname> and <apiname>setAttribute()</apiname></p>
      <p>The User object can be in either authenticated or
	non-authenticated state. When it's in the authenticated state, the
	identity of the user is known and they are considered logged in.
	Otherwise, the User object is in non-authenticated
	state.</p>
      <p>The User object also carries the credential
	information. When a secure Action is executed, Agavi reads the
	User object to see whether it is authenticated at all, and if the
	Action required any special permissions, whether these permissions
	are seen in the User object.</p>
      <p>Here's some sample code inside
	an Action's execute() method to show you how to manipulate the
	user object. The correct way to use these methods will be shown
	soon - the code below is just to give you the general idea:</p>
      <codeblock conref="../examples/examples.xml#user-object-example" class="php"/>
    </section>
  </body>
</topic>
