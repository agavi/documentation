<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN"
	  "http://docs.oasis-open.org/dita/dtd/topic.dtd">
<topic id="execution-flow-overview">
  <title>Overview of application execution flow</title>
  <body>
    <p>Agavi handles user requests and organizes the execution flow
      of an application. This chapter gives a brief overview what
      happens when a web request lands in the Agavi
      dispatcher. Understanding Agavi architecture is key to write
      efficient and durable applications.
    </p>
    <section>
      <title>Request dispatching</title>
      <p>The first stage of execution is called the dispatch
	stage. The dispatcher script -
	typically <filepath>index.php</filepath> for Web applications -
	boots the framework and commands the Agavi Controller to dispatch the Web request.
      </p>
      <p>The Controller looks up the request using the routing map to
	find out the identity of the Action that is to be executed. If
	the route doesn't match, or the specified Action can not be
	found, a substitute system action is executed instead to
	indicate an error condition.</p>
      <p>When the identity of the requested Action is discovered, the
	Controller creates a special envelope object, called the
	Execution Container. Actions and Views execute inside the
	Execution Container which isolates them from the outside world
	and provides them with a shared space to communicate to each
	other.</p>
      <p>When the initial Action is loaded into the Execution
	Container, the Controller creates the global filter chain which
	governs the execution of actions. The Execution Container is
	fed into the filter chain. The filter chain executes the
	Container, and the resulting response is returned to the
	outside world - most often, as an HTTP response.</p>
      <note type="tip">
	Filter chains are configurable pipelines which execute
	filters. A filter is a plugin-like class that accepts an
	Execution Container and does something with it. Filters are
	nested, which means they can execute before or after other
	(inner) filters.
      </note>
    </section>
    <section>
      <title>Inside the global filter chain</title>
      <p>The global filter chain doesn't do a whole lot. The last
	filter in the chain, called the dispatch filter, simply
	executes the Container and passes its response contents back
	up the filter chain. The dispatch filter is hardwired into
	the controller execution logic. The only other global filter
	that ships with a default Agavi application is the Form
	Population Filter, which is responsible for filling and
	re-filling HTML forms.
      </p>
      <p>You may add your own filters into the global filter chain,
	and they will be executed once per application (Web)
	request.</p>
    </section>
    <section>
      <title>Running the Execution Container</title>
      <p>The Execution Container governs execution of a single Action
      and the View it appoints. It sets up the environment for the
      Action-View chain, runs both Actions and Views, invokes the
      rendering mechanism to apply templates if needed, collects the
      output and returns it to the caller.</p>
      <p>The Actions/Views are executed inside another filter chain,
      which is called the "actions" filter chain. Unlike the global FC
      which is executed once per request, the actions FC is executed
      once for every Action. The Action itself is invoked through the
      Execution Filter. Output caching is performed at this stage.</p>
      <note>Several other filters may be involved in the action
      chain: for example, the security filter would refuse to execute
      an Action that the user isn't authorized to execute.</note>
      <p>If the Action requests input validation, the request data is
      checked by Agavi according to the rules laid out by
      developers. If the data does not conform to the specified
      constraints, execution of the Action is aborted and error
      handling procedure begins instead.</p>
      <p>After the validation and caching checks are finished, the
      executeXXX() method of the Action will be called. This is where
      your code comes into play: the Action interacts with Models and
      tells Agavi which View should be executed.</p>
      <p>The appointed View's respectable executeXXX() method is
      called. The View sets up the configuration for output rendering
      and prepares any data needed by the rendering mechanism, again
      querying Models if needed.</p>
      <p>After the View has finished executing, the rendering
      mechanism executes the rendering procedure. This procedure may
      involve calling other Actions, which in turn get their own
      Execution Containers and action filter chains. Alternatively, a
      View may choose to skip the rendering step and compose the
      response itself (for example, encoding API response into JSON
      would not require any sort of external templates.)</p>
      <p>The resulting output is collected and sent back to the client.</p>
    </section>
  </body>
</topic>
